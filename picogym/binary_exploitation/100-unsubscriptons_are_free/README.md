# PicoCTF: Unsubscriptions Are Free

## TL;DR:

The target program includes an uncalled function reads the flag value from a
file in the current directory into a stack allocated `char[]` buffer and prints
the buffer to stdout.

A menu option allows leaking the address of the uncalled function; presumably
the approach is to somehow invoke this function.


## Notes

`cmd *user` is a global variable.

The "(l)eave a message(with or without logging in)" option doesn't change the
function pointer associated with the user, so UAF by:
1. `m` to create `user` object with supplied username
2. `i` to delete `user` object.
3. `l` + message -> invoke function from `free()`ed `user` object.

When you choose "(I)nquire about account deletion", the `user` struct is
`free()`ed in the `i()` function

Maybe the exploit flow goes like this
1. create a `user` object
2. free it.
3. do stuff to groom the heap
4.

1. `m` to create `user` object with supplied username
2. `l` + message ("herpderp") -> invoke function from `free()`ed `user` object.
3. `i` to delete `user` object.
4. `l` + message ("herpderp")-> invoke function from `free()`ed `user` object.
5. UAF & RIP == ("herpderp")

### Reverse Engineering

My first several readings of the target binary were of its source code. However,
upon reading the Ghidra decompiler's output of the same binary I noticed several
errors in my inital reading of the actual source.

Take away: the farther one gets from reading assembly the easier it is to
misunderstand what's going on.

### Exploitation strategy

This ought to be a textbook UAF.

- We want to call a function (at a known absolute addr)
- A heap object contains a function pointer
- We get to invoke that function pointer after the heap object is `free()`ed
- We can allocate new heap objects containing arbitrary data

So...

0. Leak the address of the function we want to call.
1. Create the heap object containing a function pointer
2. `free()` the heap object.
3. Create new heap objects containing the address of the target function,
   overwriting the `free()`ed heap object's funciton pointer with the address of
   the target function.
4. Call the (now overwritten) function pointer from the `free()`ed heap object
   to invoke the target function.

This approach has a 100% success rate when run locally under GDB, about 10%
success locally without GDB, and does not appear to work at all on the remote
real target binary. Why?

Insert weeks of confusion, including attempts to do more complex grooing and
(very begrudingly) reviewing of
[PDF](https://homes.luddy.indiana.edu/yh33/Teaching/I433-2016/lec13-HeapAttacks.pdf)
referenced in the hint to understand a double-free from first principles.
Finally I gave up on the simple UAF ane decided the game server must have some
kind of undocumented variation to make exploitation require exploitation via
double-free rather than a simple UAF.

Only minutes into refactoring `solve.py` so that calls to `recv()` would be more
precise about how many bytes to expect for each interaction - and not even
realizing I was testing against the real game server - I noticed the legit flag
value in a server response.

After tightening up the implmenetation using the real game server, reliability
is quite good. Then switching back to local, reliability is much worse. Upon
testing, it appears there is more variability in the amount of bytes returned by
remote and local instance of the target process. I'm not sure why that is, but
local reliability isn't actually as bad as I thought. It's just that the flag's
position in the server response seems less consistent when run locally. I could
troubleshoot why this happens, and tune the solution to parse target responses
differently for local targets, but that doesn't seem very interesting or useful
so I'll leave this solution as-is and move on.

## Misc

While I was trying to understand why the UAF approach wasn't working on the
remote target, I spent time using gdb to try to understand glibc's `malloc` a
bit more concretely. pwntools has two particularly helpful commands: `heap` and
`bins`. The former shows the heap, including allocated and free chunks, and the
latter shows the metadata for the various free lists. There is some overlap in
the information provided by each command, but their respective presentations of
the heap data are still useful and distinct.